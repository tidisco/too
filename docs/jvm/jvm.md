# jvm
## jvm内存模型
### jvm内存的5个部分
#### 程序计数器
用来记录当前线程执行的字节码的行号，是唯一一个没有规定oom的区域，属于线程私有
#### 虚拟机栈
描述的是java方法执行模型。每一个线程的一个方法都会创建一个栈帧，用来存储方法的局部变量表，操作数，动态链接，方法出口等信息，属于线程私有
#### 本地方法栈
和虚拟机栈相同，属于线程私有，只不过存储的方法信息是native方法
#### 堆内存
存储java程序中对象具体信息的内存，属于线程共享区
#### 方法区
用来存储虚拟机加载的类信息，常量，静态变量，及时编译期编译后的代码等信息，属于线程共享区
#### 运行时常量池
属于方法区的一部分，存储编译期生成的各种字面量和符号信息。


## 虚拟机中对象的初步了解
### 未虚拟机对象分配内存的两种方式
分为指针碰撞和闲时列表
### 对象的内存分布
对象信息分为对象头，实例数据和对齐填充。对象头记分为两部分，一部分记录了对象的运行时信息，哈希码，偏向锁，GC分代等信息，另一部分是类型指针，指向该示例的类型信息。
### 对象访问的两种方式
分为句柄访问和直接指针访问。区别在于对象的类型信息是通过句柄记录的地址访问还是通过对象的类型信息访问

## oom
### 堆内存oom
要分析oom时存储的对象是否有必要存在，从而区分是内存溢出还是内存泄漏。
### 虚拟机栈和本地方法栈oom
- 当线程请求的栈深度大于虚拟机所允许的最大深度，抛出StackoverFlowError异常。（递归循环，方法调用过多）
- 当请求扩展栈无法申请到足够的空间时，抛出oom异常。（一个栈帧大小不够用）
- 经过测试，jdk1.7，在单线程下总是抛出stackoverflowerror。通过不断创建线程时，倒是可以导致oom

## 垃圾收集器与内存分配策略
### 判断对象死活
- 引用计数法。 在循环引用时，会出现不准确的情况
- 可达性分析算法。 规定一个gcroot，当一个对象无法连接到gcroot，就会被标记为死亡。如果没有从finalize方法中被拯救，然后就会死亡。(不建议使用)

### 能作为gcroots的对象
- 虚拟机栈中引用的对象 (方法中的本地变量)
- native方法的引用变量
- 方法区中静态属性应用的变量
- 方法区中常量引用的对象

### 对象的四种引用方式
- 强引用，最常用的引用
- 软引用，用描述需要但不必须的引用，这类对象，在发生oom之前会被回收
- 弱引用，被弱引用的对象只能生存到下次发生gc。当进行gc时，不管内存是否够用，都会被回收
- 虚引用，不能通过虚引用找到对象实例，它的作用就只是在被回收时会发一条系统通知。

### 垃圾收集算法
- 标记清除算法。 先标记再清除，会造成空间碎片
- 复制算法。 缺点是浪费空间。先空间分为未使用和已使用，在进行收集时，将已使用还存活对象移到未使用，并清理已使用区。 一般新生代会使用该种算法，会将内存空间按照8:1:1的比例分配。其中两个1只有一个被列为上述的未使用区域。当10%的空间不够用时，就需要将对象移至老年代。所以在这部分空间不够用时，需要将老年代空间进行担保
- 标记整理算法。先标记，在整理，后清除。 年老代常用算法
- 分代收集

### hotspot的算法实现
#### 枚举跟节点
不是每次都扫描，而是在虚拟机中记录这些信息，在发生gc时可以直接使用.
#### 安全点和安全区域
在安全点进行跟节点枚举，在进入安全区域后，需要标记为进入安全区域，在发生gc时，会不再管这样的线程。在该线程出了安全区域后，需要校验是否完成了跟节点枚举，否则必须收到可以离开的信号时才能继续。(信号什么时候发)
